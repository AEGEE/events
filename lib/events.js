var config = require('./config/config.js');
var log = require('./config/logger.js');
var restify = require('restify');
var helpers = require('./helpers.js');
var mongoose = require('./config/mongo.js');
var imageserv = require('./imageserv.js');


var Event = require('./eventModel.js');


/** Requests for all events **/

exports.listEvents = function(req, res, next) {
	Event
		.where('status').ne('deleted') // Hide deleted events
		.where('ends').gte(new Date()) // Only show events in the future
		.select(['name', 'starts', 'ends', 'description', 'type', 'status', 'max_participants', 'application_status'].join(' '))
		.sort('starts')
		.exec(function(err, events) {
		
		if (err) {log.info(err);return next(new restify.InternalError());}
		
		res.json(events);
		return next();
	});
}

exports.addEvent = function(req, res, next) {
	// Make sure the user doesn't insert malicious stuff
	// Fields with other names will be ommitted automatically by mongoose
	var data = req.body;
	delete data._id;
	delete data.status;
	delete data.applications;
	delete data.organizers;
	delete data.application_status;
	//delete data.organizing_locals;
	
	log.info('Creating new event %s', data);

	var newevent = new Event(data);
	
	// Creating user automatically becomes organizer
	newevent.organizers = [
		{
			first_name: req.user.basic.first_name,
			last_name: req.user.basic.last_name,
			foreign_id: req.user.basic.id,
			role: 'full',
		}
	];

	// Creating user's local automatically becomes organizing local
	newevent.organizing_locals = [
		{
			name: req.user.details.antenna_city,
			foreign_id: req.user.basic.antenna_id,
		}
	]


	if(data.headImg) {
		imageserv.uploadImage(data.headImg, function(err, url) {
			if(err) {log.info(err); return next(new restify.InternalError());}
			newevent.headImg = url;
			newevent.save(function(err) {
				if(err)
					return next(new restify.InvalidContentError(JSON.stringify(err)));
				delete newevent.applications;
				res.status(201);
				res.json(newevent);
				return next();
			});
		});
	} else {

		// Validate
		error = newevent.validateSync();
		if(error != null) {
			return next(new restify.InvalidArgumentError({body: error}));
		}

		newevent.save(function(err) {
			if(err) {
				log.info(err);
				return next(err);
			}
			delete newevent.applications;
			res.status(201);
			res.json(newevent);
			return next();
		});
	}
}

/** Single event **/



exports.eventDetails = function(req, res, next) {
	
	var event = req.event.toObject();
	
	// TODO: Check if user is allowed to see applications, meaning is organizer or participant
	if(event.application_status == 'open')
		delete event.applications;
	
	// TODO: Check if user is allowed to see organizers, meaning is organizer
	// delete event.organizers;
	
	res.json(event);
	return next();

}

exports.editEvent = function(req, res, next) {
	var data = req.body;
	var event = req.event;
	// TODO Check if user is organizer
	delete data.applications;
	delete data.organizers;

	if(Object.keys(event).length == 0) {
		return next(new restify.InvalidContentError({message: 'No valid field changes requested'}));
	}

	// TODO: CD/SUCT/EQUARK should still be allowed edit even if not in draft
	if (event.status != 'draft'){
		delete data.name;
		delete data.starts;
		delete data.ends;
		delete data.description;
		delete data.type;
		delete data.application_fields;
		delete data.headImg;

		if(Object.keys(event).length == 0) {
			return next(new restify.InvalidContentError({message: 'You can not edit an event when the application is open'}));
		}
	}

		
		
	// TODO Only let CD/SUCT/EQUARK members change to approved
	
	// TODO If organizing local is set, retrieve name for that
	var headImg = data.headImg;
	delete data.headImg;
	for (var key in data) {
		event[key] = data[key];
	}

		
	// Validate
	error = event.validateSync();
	if(error != null) {
		return next(new restify.InvalidArgumentError({body: error}));
	}

	event.save(function(err) {
		if (err) {log.info(err);return next(new restify.InternalError());}
		
		var retval = event.toObject();
		delete retval.applications;
		delete retval.organizers;
		delete retval.__v;
		delete retval.headImg;
		
		res.json(retval);
		return next();
	});
	
}

exports.deleteEvent = function(req, res, next) {
	// TODO Check for user privilegies
	var event = req.event;

	// Deletion is only changing status to deleted
	event.status = 'deleted';
	event.save(function(err) {
		if (err) {log.info(err);return next(new restify.InternalError());}

		res.send("Event successfully deleted");
		return next();
	});
}

// Just forward the edit rights generated by checkUserRole
exports.getEditRights = function(req, res, next) {
	var retval = req.user.permissions;

	res.json(retval);
	return next();
}

/** Participants **/
exports.listParticipants = function(req, res, next) {
	// TODO Check for user privilegies
	// Idea: Only let people see applications after application period ended
	
	var event = req.event;
		
	var applications = event.applications.toObject();
	
	applications.forEach(function(x, idx) {
		applications[idx].url = event.url + '/participants/' + applications[idx].foreign_id;
	});
	
	res.json(applications);
	return next();
}


exports.getApplication = function(req, res, next) {
	var event = req.event;
		
	// TODO check user privilegies
	// Search for the application
	var application = event.applications.find(function(element) {return element.foreign_id == req.user.basic.id;});
	if (application == undefined)
		return next(new restify.ResourceNotFoundError("User " + req.user.basic.id + " not found"));
	
	res.json(application);
	return next();
	
}

exports.setApplication = function(req, res, next) {
	var event = req.event;
		
	// TODO check user privilegies
	// TODO check if event is open for application
	
	// Find the corresponding application
	var index;
	var application = event.applications.find(function(element, idx) {
		if(element.foreign_id == req.user.basic.id) {
			index = idx;
			return true;
		}
		return false;
	});

	// If user hasn't applied yet, create an application
	if (application == undefined) {
		event.applications.push({
			foreign_id: req.user.basic.id,
			first_name: req.user.basic.first_name,
			last_name: req.user.basic.last_name,
			application: req.body.application
		});
		index = event.applications.length - 1;
	}
	else
		event.applications[index].application = req.body.application;
		
	
	
	// TODO Create new call to approve applications
	//if(application.application_status) {
	//	event.applications[index].application_status = application.application_status;  // Just copy the field
	//}
	
	// Only check the current application for validity, as checking all of them would be too much overhead on big events
	var tmp = helpers.checkApplicationValidity(event.applications[index].application, event.application_fields);
	if (!tmp.passed)
		return next(new restify.InvalidContentError('Application malformed: ' + tmp.msg));
	
	
	// Validate
	error = event.validateSync();
	if(error != null) {
		return next(new restify.InvalidArgumentError({body: error}));
	}

	event.save(function(err) {
		if (err) {log.info(err);return next(new restify.InternalError());}
		
		res.json(event.applications[index]);
		return next();
	});
}

/** Organizers **/

exports.listOrganizers = function(req, res, next) {
	// TODO Check for permissions
	var event = req.event;
		
	var data = event.organizers.toObject();
	data.forEach(function(x, idx) {
		data[idx].url = event.url + '/organizers/' + x.foreign_id;
	});
	
	res.json(data);
	return next();
}

exports.setOrganizers = function(req, res, next) {
	var event = req.event;

	var data = req.body.organizers;
	if(data.constructor !== Array)
		return next(new restify.InvalidArgumentError('Organizers list must be an array'));
	if(data.length == 0) 
		return next(new restify.InvalidArgumentError('Organizers list can not be empty'));
	

	data.forEach(function(x, idx){
		delete data[idx].cache_first_name;
		delete data[idx].cache_last_name;
		delete data[idx].cache_update;

	});

	event.organizers = data;
	error = event.validateSync();
	if(error != null) {
		return next(new restify.InvalidArgumentError({body: error}));
	}

	event.save(function(err) {
		if (err) {log.info(err);return next(new restify.InternalError());}
		res.status(200);
		res.json({organizers: event.organizers});
		return next();
	});
}

/** Nerdporn Requests **/



exports.debug = function(req, res, next) {
	Event.remove({}, function(err) {
		res.send("All events removed, can not be undone. Muhahaha. Wouldn't have guessed this is this serious, wouldn't you?");
		return next();
	});
}

/** Middleware **/


exports.fetchSingleEvent = function(req, res, next) {
	if(!req.params.event_id) {
		log.info(req.params);
		return next(new restify.NotFoundError("No Event-id provided"));
	}

	Event.findById(req.params.event_id).exec(function(err, event) {
		if (err) {
			if(err['name'] == 'CastError')
				return next(new restify.NotFoundError("Event with id " + req.params.event_id + " not found"));
			log.info(err);
			return next(new restify.InternalError());
		}
		if (event == null) 
			return next(new restify.NotFoundError("Event with id " + req.params.event_id + " not found"));
		
		req.event = event;
		return next();
	});
}

// Middleware to check which permissions the user has on this event 
// Requires the fetchSingleEvent and fetchUserDetails middleware to be executed beforehand
exports.checkUserRole = function(req, res, next) {
	var permissions = {
		is: {},
		can: {}
	}

	permissions.is.organizer = req.event.organizers.some(function(item) {
		return item.foreign_id == req.user.basic.id;
	});

	var application_index;

	permissions.is.participant = req.event.applications.some(function(item, index) {
		if(item.foreign_id == req.user.basic.id) {
			application_index = index;
			return true;
		}
		return false;
	});

	permissions.is.accepted_participant = permissions.is.participant && req.event.applications[application_index].application_status == 'accepted';

	permissions.is.own_antenna = req.event.organizing_locals.some(function(item) {
		return item.foreign_id == req.user.basic.antenna_id;
	});

	permissions.is.boardmember = permissions.is.own_antenna && req.user.board_positions.length > 0;

	permissions.is.superadmin = req.user.basic.is_superadmin;

	permissions.is.cdmember = false; // TODO

	permissions.is.netcommie = false; // TODO maybe also check if user is netcommie for this local

	permissions.is.suct = false; // TODO

	permissions.can.edit_details = 
		(permissions.is.organizer && req.event.application_status == 'closed' && req.event.status == 'draft') // Normal editing
		|| permissions.is.superadmin // of course
		|| permissions.is.cdmember;

	permissions.can.edit_application_status = 
		(permissions.is.organizer && req.event.status == 'approved')
		|| permissions.is.superadmin
		|| permissions.is.cdmember;

	permissions.can.approve = 
		permissions.is.superadmin
		|| permissions.is.cdmember
		|| (permissions.is.netcommie && req.event.type == 'non-statutory')
		|| (permissions.is.suct && req.event.type == 'su');

	permissions.can.edit = 
		permissions.can.edit_details 
		|| permissions.can.edit_application_status 
		|| permissions.can.approve;

	permissions.can.apply = !permissions.is.organizer && req.event.application_status == 'open';

	permissions.can.approve_participants = permissions.is.organizer;

	permissions.can.view_participants = 
		permissions.is.organizer 
		|| permissions.is.accepted_participant 
		|| permissions.is.boardmember
		|| permissions.is.superadmin
		|| permissions.is.cdmember
		|| (permissions.is.netcommie && req.event.type == 'non-statutory')
		|| (permissions.is.suct && req.event.type == 'su');

	// Convert all to boolean
	for(var attr in permissions.is) {
		permissions.is[attr] = Boolean(permissions.is[attr]);
	}
	for(var attr in permissions.can) {
		permissions.can[attr] = Boolean(permissions.can[attr]);
	}

	req.user.permissions = permissions;

	return next();
}

